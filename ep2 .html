<!dctype html>
<html>
<title> capstone_design-example_2 </title>

    <html lang="en">
        <head>
           
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
            <meta name="generator" content="FreeCAD 0.19.24366 (Git)" />
            <style>
                * { margin:0; padding:0; }
                body{
                    background: #ffffff; /* Old browsers */
                    background: -moz-linear-gradient(top, #e3e9fc 0%, #ffffff 70%, #e2dab3 100%); /* FF3.6-15 */
                    background: -webkit-linear-gradient(top, #e3e9fc 0%,#ffffff 70%,#e2dab3 100%); /* Chrome10-25, Safari5.1-6 */
                    background: linear-gradient(to bottom, #e3e9fc 0%,#ffffff 70%,#e2dab3 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
                }
                canvas { display: block; }
                #arrowCanvas  {
                  position: absolute;
                  left: 0px;
                  bottom: 0px;
                  z-index: 100;
                }
                select { width: 170px; }
            </style>
        </head>
        <body>
            <script type="module">
                
                // Direct from mrdoob - r122(10/28/20): https://www.jsdelivr.com/package/npm/three
                import * as THREE from            'https://cdn.jsdelivr.net/npm/three@0.122.0/build/three.module.js';
                import { OrbitControls } from     'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/controls/OrbitControls.js';
                import Stats from                 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/libs/stats.module.js';
                import { GUI } from               'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/libs/dat.gui.module.js';
                import { Line2 } from             'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/Line2.js';
                import { LineMaterial } from      'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/LineMaterial.js';
                import { LineGeometry } from      'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/LineGeometry.js';
                import { EdgeSplitModifier } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/modifiers/EdgeSplitModifier.js';
                
                var disableCompression = false;
                var base = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!#$%&()*+-:;/=>?@[]^_,.{|}~`';
                var baseFloat = ',.-0123456789';
                
                THREE.Object3D.DefaultUp = new THREE.Vector3(0,0,1); // Z is up for FreeCAD
                
                var raycasterObj = []; // list of obj that can mouseover highlight 
                
                var scene = new THREE.Scene();
                
                var renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } ); // Clear bg so we can set it with css
                renderer.setClearColor( 0x000000, 0 );
                var mainCanvas = document.body.appendChild( renderer.domElement );
                mainCanvas.setAttribute('id', 'mainCanvas');
                
                // HemisphereLight gives different colors of light from the top and bottom simulating reflected light from the 'ground' and 'sky'
                scene.add(new THREE.HemisphereLight(0xC7E8FF, 0xFFE3B3, 0.4));
                
                var dLight1 = new THREE.DirectionalLight( 0xffffff, 0.4 );
                dLight1.position.set( 5, -2, 3 );
                scene.add( dLight1 );
                var dLight2 = new THREE.DirectionalLight( 0xffffff, 0.4 );
                dLight2.position.set( -5, 2, 3 );
                scene.add( dLight2 );
                
                var data = {"camera":{"type":"Orthographic","focalDistance":32.832908630371094,"position_x":-35.86198806762695,"position_y":25.857295989990234,"position_z":50.743289947509766},"file":{},"objects":[{"name":"Body","color":"#cccccc","opacity":1.0,"verts":"2 e b d a b d a b c e b cxdyd d . M dzdAd dBdCd dDdEd dFdGd dHdId dJdKd dLdMd dNdOd dPdQd dRdSd dTdUd dVdWd dkblb dXdYd d d c dZdWd dRd1d d2dMd dFd3d d4dCd dxd5d d6dyd dBd7d d d f d2d8d d4d7d dZd9d dVd9d dLd8d d0dyd d!dGd d#dCd d$dGd d%dMd d&dSd d(dSd dqclb d)dWd dXclb d*dWd d+dQd d&d1d d(d1d d!d3d d-dMd d:dOd d;dEd d$d3d d6d5d d/dCd d=dAd d0d5d d>dyd d L M d#d7d d?dGd d@dId d[dKd d]dSd d^dUd dwdlb d_dYd d g c d]d1d d?d3d d>d5d d/d7d d g f d-d8d d*d9d d)d9d d%d8d dPdQd cNdOd cDdEd czdAd c . M cHdId cJdKd cTdUd cXdYd c d c c+dQd c:dOd c;dEd c=dAd c L M c@dId c[dKd c^dUd c_dYd c g c cxdyd cBdCd cFdGd cLdMd cRdSd cVdWd ckblb cZdWd cRd1d c2dMd cFd3d c4dCd cxd5d c6dyd cBd7d c d f c2d8d c4d7d cZd9d cVd9d cLd8d c!dGd c0dyd c#dCd c$dGd c%dMd c(dSd c&dSd cqclb c)dWd cXclb c*dWd c(d1d c&d1d c!d3d c-dMd c$d3d c6d5d c/dCd c0d5d c>dyd c#d7d c?dGd c]dSd cwdlb c]d1d c?d3d c>d5d c/d7d c g f c-d8d c*d9d c)d9d c%d8d c","facets":"2 a b c a c d e f g h g i h e g j k f j l k j f e m h i m n o m i n p l j p q l r m o r o b s t q s u t s q p v r b w u s x v b y u w z x b A u y B z b C u A D u C D E F D G E D H G D I H D C I a B b J K B J B a L J a M K J N L a O P K O Q P O K M R N a S Q O T a U T R a V W Q V X W V Q S Y U Z Y Z 1 Y T U 2 X V 2 3 X 4 1 5 4 Y 1 6 F 3 6 3 2 7 4 5 8 7 5 9 F 6 0 7 8 ! 0 8 # $ 0 # 0 ! % & $ % $ # ( & % ) & ( ) * & ) + * ) - + ) : - ; : ) ; D F ; / : ; = / ; > = ; ? > ; 9 ? ; F 9 @ b o @ c b [ o n [ n i [ @ o ] [ i ^ i g ^ g f ^ ] i _ ^ f , f k , _ f . k l . , k { l q { . l | q t | t u | { q } | u a ~ U d ~ a U ` Z Z ` 1 ~ ` U `ab 1 1bb 5 5bb 8abbb 1bbcb 8 8db !cbdb 8 !eb #dbeb ! #fb %ebfb # %gb ( (gb )fbgb %gbhb ) _ib ^ ^jb ]ibjb ^ ,kb _ .kb , _kbibjblb ] [lb @ ]lb [ .mbkb {mb .lbnb @ @nb c |ob { }ob | {obmbnbpb c }qbobpbrb c }sbqbrbtb c }ubsbtbvb c }wbub }xbwbybxbzbAbxbybBbxbAbCbxbBbwbxbCbvb d cDbEbvbvbEb dEbFb dDbGbEbFbHb dIbJbDbKbJbIbDbJbGbHbLb dKbMbJb dNb ~LbNb dObPbKbQbPbObKbPbMb ~Rb ` `RbabNbRb ~QbSbPbTbSbQbabUbbbRbUbabzbVbTbTbVbSbUbWbbbWbcbbbzbXbVbWbYbcbYbdbcbZbebYbYbebdb1bfbZbZbfbeb1bgbfb1bhbgb2bhb1b3bhb2b4bhb3b5bhb4b5b6bhbxb6bzb7b6b5b8b6b7b9b6b8b0b6b9bXb6b0bzb6bXb u Dxb uxb } ; )hb ;hb6bxb ;6b D ;xb s pobob pmbmb jkbkb jib p jmb j eibib hjb e hibjb mlb h mjblb rnbnb rpb m rlb r vpbpb xrb v xpbrb ztb x zrbtb Bvb z Btb B Kvbvb KDb K PDbDb PIb P QIbIb QKb Q WKbKb WOb W XObOb XQb X 3QbQb 3TbTb 3zb 3 Fzb F Ezbzb Eybyb EAb E GAb G HAbAb HBb H IBbBb ICb I CCbCb Cwbwb Cub C Aubub ysb A yubsb wqb y wsbqb sob w sqb S OMbMb OJbJb MGbGb MEb O MJb M JEbEb LFb J LEbFb NHb L NFbHb RLbLb RNb N RHb R TNbNb YRb T YNbRb 4Ub Y 4RbUb 7Wb 4 7Ub 7 0WbWb 0Yb 0 $YbYb $Zb $ &ZbZb &1b & *1b1b *2b * +2b2b +3b + -3b3b -4b4b -5b - :5b : /5b5b /7b7b /8b / =8b = >8b8b >9b > ?9b9b ?0b ? 90b0b 9XbXb 9Vb 9 6VbVb 2Sb 6 2VbSb VPb 2 VSbPb SMb V SPb","wires":["1abcaddebdedcadc","2 d c d d f d g f d g c d h i d j k d l m d n o d p q d r s d t u d v w d x y d z A d B C d D E d F G d H I d J K d L M d N O d P Q d R S d T U d V W d X Y d Z 1 d 2 3 d 4 5 d 6 7 d 8 9 d 0 ! d # $ d % & d ( ) d e d d a b d * ) d + & d - $ d : ! d ; 9 d / 7 d = 5 d > 3 d ? 1 d @ Y d [ W d ] U d ^ S d _ Q d , O d . M d { K d | I d } G d ~ E d ` C dab A dbb y dcb w ddb u deb s dfb q dgb o dhb m dib k djb i d d c d","2kblb dmbnb dobpb dqbrb dsbtb dubvb dwbxb dybzb dAbBb dCbDb dEbFb dGbHb dIbJb dKbLb dMbNb dObPb dQbRb dSbTb dUbVb dWbXb dYbZb d1b2b d3b4b d5b6b d7b8b d9b0b d!b#b d$b%b d&b(b d)b*b d+b-b d:b;b d a/b d=b;b d>b-b d?b*b d@b(b d[b%b d]b#b d^b0b d_b8b d,b6b d.b4b d{b2b d|bZb d}bXb d~bVb d`bTb dacRb dbcPb dccNb ddcLb decJb dfcHb dgcFb dhcDb dicBb djczb dkcxb dlcvb dmctb dncrb docpb dpcnb dqclb dpcrc docsc dnctc dmcuc dlcvc dkcwc djcxc dicyc dhczc dgcAc dfcBc decCc ddcDc dccEc dbcFc dacGc d`bHc d~bIc d}bJc d|bKc d{bLc d.bMc d,bNc d_bOc d^bPc d]bQc d[bRc d@bSc d?bTc d>bUc d=bVc d aWc d:bVc d+bUc d)bTc d&bSc d$bRc d!bQc d9bPc d7bOc d5bNc d3bMc d1bLc dYbKc dWbJc dUbIc dSbHc dQbGc dObFc dMbEc dKbDc dIbCc dGbBc dEbAc dCbzc dAbyc dybxc dwbwc dubvc dsbuc dqbtc dobsc dmbrc dkblb d","2Xclb dYcnb dZcpb d1crb d2ctb d3cvb d4cxb d5czb d6cBb d7cDb d8cFb d9cHb d0cJb d!cLb d#cNb d$cPb d%cRb d&cTb d(cVb d)cXb d*cZb d+c2b d-c4b d:c6b d;c8b d/c0b d=c#b d>c%b d?c(b d@c*b d[c-b d]c;b d e/b d^c;b d_c-b d,c*b d.c(b d{c%b d|c#b d}c0b d~c8b d`c6b dad4b dbd2b dcdZb dddXb dedVb dfdTb dgdRb dhdPb didNb djdLb dkdJb dldHb dmdFb dndDb dodBb dpdzb dqdxb drdvb dsdtb dtdrb dudpb dvdnb dwdlb dvdrc dudsc dtdtc dsduc drdvc dqdwc dpdxc dodyc dndzc dmdAc dldBc dkdCc djdDc didEc dhdFc dgdGc dfdHc dedIc dddJc dcdKc dbdLc dadMc d`cNc d~cOc d}cPc d|cQc d{cRc d.cSc d,cTc d_cUc d^cVc d eWc d]cVc d[cUc d@cTc d?cSc d>cRc d=cQc d/cPc d;cOc d:cNc d-cMc d+cLc d*cKc d)cJc d(cIc d&cHc d%cGc d$cFc d#cEc d!cDc d0cCc d9cBc d8cAc d7czc d6cyc d5cxc d4cwc d3cvc d2cuc d1ctc dZcsc dYcrc dXclb d","2 a b c a b d * ) d + & d - $ d : ! d ; 9 d / 7 d = 5 d > 3 d ? 1 d @ Y d [ W d ] U d ^ S d _ Q d , O d . M d { K d | I d } G d ~ E d ` C dab A dbb y dcb w ddb u deb s dfb q dgb o dhb m dib k djb i d d c d d c cjb i cib k chb m cgb o cfb q ceb s cdb u ccb w cbb y cab A c ` C c ~ E c } G c | I c { K c . M c , O c _ Q c ^ S c ] U c [ W c @ Y c ? 1 c > 3 c = 5 c / 7 c ; 9 c : ! c - $ c + & c * ) c a b c","1ebcebd()d%&d#$d0!d89d67d45d23dZ1dXYdVWdTUdRSdPQdNOdLMdJKdHIdFGdDEdBCdzAdxydvwdtudrsdpqdnodlmdjkdhidgcdgcchicjkclmcnocpqcrsctucvwcxyczAcBCcDEcFGcHIcJKcLMcNOcPQcRScTUcVWcXYcZ1c23c45c67c89c0!c#$c%&c()cebc","2 d c c d f c g f c g c c h i c j k c l m c n o c p q c r s c t u c v w c x y c z A c B C c D E c F G c H I c J K c L M c N O c P Q c R S c T U c V W c X Y c Z 1 c 2 3 c 4 5 c 6 7 c 8 9 c 0 ! c # $ c % & c ( ) c e d c a b c * ) c + & c - $ c : ! c ; 9 c / 7 c = 5 c > 3 c ? 1 c @ Y c [ W c ] U c ^ S c _ Q c , O c . M c { K c | I c } G c ~ E c ` C cab A cbb y ccb w cdb u ceb s cfb q cgb o chb m cib k cjb i c d c c","2kblb cmbrc cobsc cqbtc csbuc cubvc cwbwc cybxc cAbyc cCbzc cEbAc cGbBc cIbCc cKbDc cMbEc cObFc cQbGc cSbHc cUbIc cWbJc cYbKc c1bLc c3bMc c5bNc c7bOc c9bPc c!bQc c$bRc c&bSc c)bTc c+bUc c:bVc c aWc c=bVc c>bUc c?bTc c@bSc c[bRc c]bQc c^bPc c_bOc c,bNc c.bMc c{bLc c|bKc c}bJc c~bIc c`bHc cacGc cbcFc cccEc cdcDc cecCc cfcBc cgcAc chczc cicyc cjcxc ckcwc clcvc cmcuc cnctc cocsc cpcrc cqclb cpcnb cocpb cncrb cmctb clcvb ckcxb cjczb cicBb chcDb cgcFb cfcHb cecJb cdcLb cccNb cbcPb cacRb c`bTb c~bVb c}bXb c|bZb c{b2b c.b4b c,b6b c_b8b c^b0b c]b#b c[b%b c@b(b c?b*b c>b-b c=b;b c a/b c:b;b c+b-b c)b*b c&b(b c$b%b c!b#b c9b0b c7b8b c5b6b c3b4b c1b2b cYbZb cWbXb cUbVb cSbTb cQbRb cObPb cMbNb cKbLb cIbJb cGbHb cEbFb cCbDb cAbBb cybzb cwbxb cubvb csbtb cqbrb cobpb cmbnb ckblb c","2Xclb cYcrc cZcsc c1ctc c2cuc c3cvc c4cwc c5cxc c6cyc c7czc c8cAc c9cBc c0cCc c!cDc c#cEc c$cFc c%cGc c&cHc c(cIc c)cJc c*cKc c+cLc c-cMc c:cNc c;cOc c/cPc c=cQc c>cRc c?cSc c@cTc c[cUc c]cVc c eWc c^cVc c_cUc c,cTc c.cSc c{cRc c|cQc c}cPc c~cOc c`cNc cadMc cbdLc ccdKc cddJc cedIc cfdHc cgdGc chdFc cidEc cjdDc ckdCc cldBc cmdAc cndzc codyc cpdxc cqdwc crdvc csduc ctdtc cudsc cvdrc cwdlb cvdnb cudpb ctdrb csdtb crdvb cqdxb cpdzb codBb cndDb cmdFb cldHb ckdJb cjdLb cidNb chdPb cgdRb cfdTb cedVb cddXb ccdZb cbd2b cad4b c`c6b c~c8b c}c0b c|c#b c{c%b c.c(b c,c*b c_c-b c^c;b c e/b c]c;b c[c-b c@c*b c?c(b c>c%b c=c#b c/c0b c;c8b c:c6b c-c4b c+c2b c*cZb c)cXb c(cVb c&cTb c%cRb c$cPb c#cNb c!cLb c0cJb c9cHb c8cFb c7cDb c6cBb c5czb c4cxb c3cvb c2ctb c1crb cZcpb cYcnb cXclb c","1dccdcddfddfcdcc","1gccgcdgfdgfcgcc","1dfcdfdgfdgfcbfc","2kblb dmbrc dobsc dqbtc dsbuc dubvc dwbwc dybxc dAbyc dCbzc dEbAc dGbBc dIbCc dKbDc dMbEc dObFc dQbGc dSbHc dUbIc dWbJc dYbKc d1bLc d3bMc d5bNc d7bOc d9bPc d!bQc d$bRc d&bSc d)bTc d+bUc d:bVc d aWc d=bVc d>bUc d?bTc d@bSc d[bRc d]bQc d^bPc d_bOc d,bNc d.bMc d{bLc d|bKc d}bJc d~bIc d`bHc dacGc dbcFc dccEc ddcDc decCc dfcBc dgcAc dhczc dicyc djcxc dkcwc dlcvc dmcuc dnctc docsc dpcrc dqclb dpcnb docpb dncrb dmctb dlcvb dkcxb djczb dicBb dhcDb dgcFb dfcHb decJb ddcLb dccNb dbcPb dacRb d`bTb d~bVb d}bXb d|bZb d{b2b d.b4b d,b6b d_b8b d^b0b d]b#b d[b%b d@b(b d?b*b d>b-b d=b;b d a/b d:b;b d+b-b d)b*b d&b(b d$b%b d!b#b d9b0b d7b8b d5b6b d3b4b d1b2b dYbZb dWbXb dUbVb dSbTb dQbRb dObPb dMbNb dKbLb dIbJb dGbHb dEbFb dCbDb dAbBb dybzb dwbxb dubvb dsbtb dqbrb dobpb dmbnb dkblb dkblb cmbnb cobpb cqbrb csbtb cubvb cwbxb cybzb cAbBb cCbDb cEbFb cGbHb cIbJb cKbLb cMbNb cObPb cQbRb cSbTb cUbVb cWbXb cYbZb c1b2b c3b4b c5b6b c7b8b c9b0b c!b#b c$b%b c&b(b c)b*b c+b-b c:b;b c a/b c=b;b c>b-b c?b*b c@b(b c[b%b c]b#b c^b0b c_b8b c,b6b c.b4b c{b2b c|bZb c}bXb c~bVb c`bTb cacRb cbcPb cccNb cdcLb cecJb cfcHb cgcFb chcDb cicBb cjczb ckcxb clcvb cmctb cncrb cocpb cpcnb cqclb cpcrc cocsc cnctc cmcuc clcvc ckcwc cjcxc cicyc chczc cgcAc cfcBc cecCc cdcDc cccEc cbcFc cacGc c`bHc c~bIc c}bJc c|bKc c{bLc c.bMc c,bNc c_bOc c^bPc c]bQc c[bRc c@bSc c?bTc c>bUc c=bVc c aWc c:bVc c+bUc c)bTc c&bSc c$bRc c!bQc c9bPc c7bOc c5bNc c3bMc c1bLc cYbKc cWbJc cUbIc cSbHc cQbGc cObFc cMbEc cKbDc cIbCc cGbBc cEbAc cCbzc cAbyc cybxc cwbwc cubvc csbuc cqbtc cobsc cmbrc ckblb c","2Xclb dYcrc dZcsc d1ctc d2cuc d3cvc d4cwc d5cxc d6cyc d7czc d8cAc d9cBc d0cCc d!cDc d#cEc d$cFc d%cGc d&cHc d(cIc d)cJc d*cKc d+cLc d-cMc d:cNc d;cOc d/cPc d=cQc d>cRc d?cSc d@cTc d[cUc d]cVc d eWc d^cVc d_cUc d,cTc d.cSc d{cRc d|cQc d}cPc d~cOc d`cNc dadMc dbdLc dcdKc dddJc dedIc dfdHc dgdGc dhdFc didEc djdDc dkdCc dldBc dmdAc dndzc dodyc dpdxc dqdwc drdvc dsduc dtdtc dudsc dvdrc dwdlb dvdnb dudpb dtdrb dsdtb drdvb dqdxb dpdzb dodBb dndDb dmdFb dldHb dkdJb djdLb didNb dhdPb dgdRb dfdTb dedVb dddXb dcdZb dbd2b dad4b d`c6b d~c8b d}c0b d|c#b d{c%b d.c(b d,c*b d_c-b d^c;b d e/b d]c;b d[c-b d@c*b d?c(b d>c%b d=c#b d/c0b d;c8b d:c6b d-c4b d+c2b d*cZb d)cXb d(cVb d&cTb d%cRb d$cPb d#cNb d!cLb d0cJb d9cHb d8cFb d7cDb d6cBb d5czb d4cxb d3cvb d2ctb d1crb dZcpb dYcnb dXclb dXclb cYcnb cZcpb c1crb c2ctb c3cvb c4cxb c5czb c6cBb c7cDb c8cFb c9cHb c0cJb c!cLb c#cNb c$cPb c%cRb c&cTb c(cVb c)cXb c*cZb c+c2b c-c4b c:c6b c;c8b c/c0b c=c#b c>c%b c?c(b c@c*b c[c-b c]c;b c e/b c^c;b c_c-b c,c*b c.c(b c{c%b c|c#b c}c0b c~c8b c`c6b cad4b cbd2b ccdZb cddXb cedVb cfdTb cgdRb chdPb cidNb cjdLb ckdJb cldHb cmdFb cndDb codBb cpdzb cqdxb crdvb csdtb ctdrb cudpb cvdnb cwdlb cvdrc cudsc ctdtc csduc crdvc cqdwc cpdxc codyc cndzc cmdAc cldBc ckdCc cjdDc cidEc chdFc cgdGc cfdHc cedIc cddJc ccdKc cbdLc cadMc c`cNc c~cOc c}cPc c|cQc c{cRc c.cSc c,cTc c_cUc c^cVc c eWc c]cVc c[cUc c@cTc c?cSc c>cRc c=cQc c/cPc c;cOc c:cNc c-cMc c+cLc c*cKc c)cJc c(cIc c&cHc c%cGc c$cFc c#cEc c!cDc c0cCc c9cBc c8cAc c7czc c6cyc c5cxc c4cwc c3cvc c2cuc c1ctc cZcsc cYcrc cXclb c"],"faceColors":[],"facesToFacets":["1ab","1cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!#$%&()*+-:;/=>?@[","2 ] ^ _ , . { | } ~ `abbbcbdbebfbgbhbibjb","2kblbmbnbobpbqbrbsbtbubvbwbxbybzbAbBbCbDb","2EbFbGbHbIbJbKbLbMbNbObPbQbRbSbTbUbVbWbXbYbZb1b2b3b4b5b6b7b8b9b0b!b#b$b%b&b(b)b*b+b-b:b;b/b=b>b?b@b[b]b^b_b,b.b{b|b}b~b`bacbcccdcecfcgchcicjckclcmcncocpcqcrc","2sctc","2ucvc","2wcxc","2yczcAcBcCcDcEcFcGcHcIcJcKcLcMcNcOcPcQcRcScTcUcVcWcXcYcZc1c2c3c4c5c6c7c8c9c0c!c#c$c%c&c(c)c*c+c-c:c;c/c=c","2>c?c@c[c]c^c_c,c.c{c|c}c~c`cadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwdxdydzdAdBdCdDdEdFdGdHdIdJdKdLd"],"floats":"[gKp#/Jv{4Uv~@yiRaTu2zCb0.Tv`9Uv$S15of}ty;L@m+~3Ysj51@N2_9]=Obm[HE{k,pYrf7.>P;3^j;=l>>f(CXFb@Rm,GS%._rVOv77ehf}t?w*TmO/Fx&g5zV*[[&MYcdG=2J5j|2UruUvNQBE[Xn?jA]nVnyFb3|fJKbWXRKKByqld/DC&7gBAmKaNZlf45qL&!ZU_8a2)z^pldTNrowV_sV0{9[gn%MSBM7Dbxyq7;3n?z)m]G]icD-1AX9dE:HvGo7a1aEi2q9VC6|)=YthmCFsrGr`]y;*Y>m@m|,8ub=Cb8!p{9[{{`4}2%I1bTEg2MR,$LJPCvs`XD{D&8bZE6531@{Ciu7Ltd>tHtyA{e8w5?SR;CJLby+6IHS%.p+OlKq[rQzC&TOuY.KgNWGCVb-Ab>4xPIbWXeqXlN|Fqxf1A4rq[]au8x!=H!CqbT7a_+3n?!}JkVaEpp&W[ltfwTi}+-]$uO0mb`vl05[{{~bnjlb/o1B;NrWq=X9jwxn:2LQog0||tS}%5]5gJ(V^kHEx]zEEbv9z)hy[w=z{7mG7m!4Ir|f)8_NOR6x}%o$4uyIEb}Y{x-XrF}EUm[QhC~q.:sD{Iu1z_Fxv9~;rc#BuNC/hWH/>j:L[r5e5[1W+vJu9T}vIBx?Hb%rNY~f|5KZ1l|whD|dtH%oY/iMzGxt39xJvcjS$MlA6Y#r4kDOJsF$m2jKnY2g}1$3cIKLLbEzX5-VT8-17mj-jDDzh2)Bv0G.@ysEZ;p[ycR6.Y1rV>f|Mjvx_s0yzH$VH!.SG^rcTO-FSbT~~zGR@DNY{j2v3DzpZ[p$m[:v]Z?]I]F{yci81794Uvn41uW5qbN|NC}kZl`wKpH;S^>^uAYr1CKn,:(XrF*pKB7^qbEP`V4i@iIrRp>S.YrE53QajD0Pf2,f|5$AHOINrb*TcHak.jV(Up%Ye6Jq,0`c4D$@ZA%VT85w&O5#rbbF6:NEajUuYp$pW,nn5Pj=jEq3NUyR@DcjoVt$rb9ol>qp0k7zYpcwMv>/k_&lf8bYzRyD@inrs(E4of%sTH]|LvV,U:`}_+4]I@d?8lfpL9M:6e;CD2.(qK,d):G+tGX!U$#R^keI(2^*lexK*[k^9J]`>DaHLQ^&4>F%hm;zwV-}5dNx@8w6PZ?Yh@sDVJu{/3Hg/kD2*q^^Jvp{/3#z^Td|B&q]F1CfC]slAb2DB1E4!l~6*qAj{x>&4>BJ_Tgvg2^icQ+4XuAsBblDG>5gmka#,q$$MYR!U$_N{VWVsH_#:-J5pB:QBb}k/_c3!knx}q2+W5W]I@Yg{W-)|tOh--hp,H&(Bb2RbTNp[mWrertQ~z_XzR%uQXn2sHpWV:`tgVtACb_|NC}kZl:@hr1[S^>^uAjxRYne.:+XrF4+[2DZCb;P`V4i@ir;orfZ.YrE53bgaZMGg2|f|5Y^>&fjDbwUcHak.jEHsr.5e6Jq,0WiUZP*1A)VT8Q?t(BHDbSF6:NEajD>vr,vW,nn5P7]a1,SOUBR@D@#6;]HDbnpl>qp0kP^vrd|Jvp?oQz!wwO%cV0tkcdt=N7g~ShBI.xKXktznB*(Hb7TOYsZv@})R^ZE@iN(Dp_eeOgX~zws8x&&W:.F19lr2bNR=N_Y^6&aEK]6Ol38s(y!mb!/MXGyA{7#=YJG{kne/oG%WH~Aq$r#(5{dVun^qbADx7>JnAw0iDAf5[girWK+fkykjD(p^N*h0+MPEZ_,.VU}{thq&>HpAB|rBb4F>5OHDk64*q*s:+,*-Sl|PXyc.:#XqX%?;2/YCbgAx7}65i`^vr%[S^uyL6MkW1wIg2/CN%6Cu(tyFb|HAwS|]m9@vrlj0K%Vn45~i5D,/:"}]};
                
                function baseDecode( input ) {
                    var baseCt = base.length;
                    var output = [];
                    var len = parseInt( input[0] ); // num chars of each element
                    for ( var i=1; i<input.length; i+=len ) {
                        var str = input.substring(i, i+len).trim();
                        var val = 0;
                        for ( var s=0; s<str.length; s++ ) {
                            var ind = base.indexOf(str[s]);
                            val += ind * Math.pow(baseCt, s);
                        }
                        output.push(val);
                    }
                    return output;
                }
                function floatDecode( input ) {
                    var baseCt = base.length;
                    var baseFloatCt = baseFloat.length;
                    var numString = '';
                    for ( var i=0; i<input.length; i+=4 ) {
                        var b90chunk = input.substring(i, i+4).trim();
                        var quotient = 0;
                        for ( var s=0; s<b90chunk.length; s++ ) {
                            var ind = base.indexOf(b90chunk[s]);
                            quotient += ind * Math.pow(baseCt, s);
                        }
                        var buffer = '';
                        for ( var s=0; s<7; s++ ) {
                            buffer = baseFloat[ quotient % baseFloatCt ] + buffer;
                            quotient = parseInt(quotient / baseFloatCt);
                        }
                        numString += buffer;
                    }
                    var trailingCommas = 0;
                    for ( var s=1; s<7; s++ ) {
                        if( numString[ numString.length-s ] == baseFloat[0] ) { trailingCommas++; }
                    }
                    numString = numString.substring(0, numString.length - trailingCommas);
                    return numString;
                }
                // Decode from base90 and distribute the floats
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    if (!disableCompression) {
                        data.objects[obj].floats = JSON.parse('[' + floatDecode( data.objects[obj].floats ) + ']');
                        data.objects[obj].verts = baseDecode( data.objects[obj].verts );
                        for ( var v=0; v<data.objects[obj].verts.length; v++ ) {
                            data.objects[obj].verts[v] = data.objects[obj].floats[ data.objects[obj].verts[v] ];
                        }
                        data.objects[obj].facets = baseDecode( data.objects[obj].facets );
                        for ( var w=0; w<data.objects[obj].wires.length; w++ ) {
                            data.objects[obj].wires[w] = baseDecode( data.objects[obj].wires[w] );
                            for ( var wv=0; wv<data.objects[obj].wires[w].length; wv++ ) {
                                data.objects[obj].wires[w][wv] = data.objects[obj].floats[ data.objects[obj].wires[w][wv] ];
                            }
                        }
                        for ( var f=0; f<data.objects[obj].facesToFacets.length; f++ ) {
                            data.objects[obj].facesToFacets[f] = baseDecode( data.objects[obj].facesToFacets[f] );
                        }
                    }
                    data.objects[obj].floats = false;
                }
                
                // Get bounds for global clipping
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    if (obj == 0) {
                        var globalMaxMin = [{min:data.objects[obj].verts[0],max:data.objects[obj].verts[0]},
                                            {min:data.objects[obj].verts[1],max:data.objects[obj].verts[1]},
                                            {min:data.objects[obj].verts[2],max:data.objects[obj].verts[2]}]
                    }
                    for ( var v=0; v<data.objects[obj].verts.length; v++ ) {
                        if ( data.objects[obj].verts[v] < globalMaxMin[v % 3].min ) { globalMaxMin[v % 3].min = data.objects[obj].verts[v]; }
                        if ( data.objects[obj].verts[v] > globalMaxMin[v % 3].max ) { globalMaxMin[v % 3].max = data.objects[obj].verts[v]; }
                    }
                }
                var bigrange = 0;
                for ( var i=0; i<globalMaxMin.length; i++ ) { // add a little extra
                    var range = globalMaxMin[i].max - globalMaxMin[i].min;
                    if ( range > bigrange ) { bigrange = range; }
                    globalMaxMin[i].min -= range * 0.01;
                    globalMaxMin[i].max += range * 0.01;
                }
                
                var camCenter = new THREE.Vector3(
                    0.5 * (globalMaxMin[0].max - globalMaxMin[0].min) + globalMaxMin[0].min,
                    0.5 * (globalMaxMin[1].max - globalMaxMin[1].min) + globalMaxMin[1].min,
                    0.5 * (globalMaxMin[2].max - globalMaxMin[2].min) + globalMaxMin[2].min );
                var viewSize = 1.5 * bigrange; // make the view area a little bigger than the object
                var aspectRatio = window.innerWidth / window.innerHeight;
                var originalAspect = aspectRatio 
                function initCam(camera) {
                    camera.position.set(
                        data.camera.position_x,
                        data.camera.position_y,
                        data.camera.position_z);
                    camera.lookAt( camCenter );
                    camera.updateMatrixWorld();
                }
                var cameraType = data.camera.type;
                var persCamera = new THREE.PerspectiveCamera( data.camera.focalDistance, window.innerWidth / window.innerHeight, 1, 10000 );
                initCam(persCamera);
                var orthCamera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2, aspectRatio * viewSize / 2, viewSize / 2, -viewSize / 2, -10000, 10000);
                initCam(orthCamera);
                
                function assignMesh( positions, color, opacity ) {
                    
                    var geometry = new THREE.BufferGeometry();
                    geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                    
                    // EdgeSplitModifier is used to combine verts so that smoothing normals can be generated WITHOUT removing the hard edges of the design
                    // REF: https://threejs.org/examples/?q=edge#webgl_modifier_edgesplit - https://github.com/mrdoob/three.js/pull/20535
                    var edgeSplit = new EdgeSplitModifier();
                    var cutOffAngle = 20;
                    geometry = edgeSplit.modify( geometry, cutOffAngle * Math.PI / 180 );
                    geometry.computeVertexNormals();
                    geometry.computeBoundingSphere();
                    
                    var transparent = false;
                    if (opacity != 1.0) { transparent = true; }
                    var material = new THREE.MeshLambertMaterial({
                        color: color,
                        side: THREE.DoubleSide,
                        vertexColors: false,
                        flatShading: false,
                        opacity: opacity,
                        transparent: transparent,
                        fog: false
                    });
                    
                    var meshobj = new THREE.Mesh( geometry, material );
                    meshobj.name = meshobj.uuid;
                    faces.push( meshobj.uuid );
                    scene.add( meshobj );
                    raycasterObj.push(meshobj);
                }
                
                var objects = [];
                var positions;
                for ( var obj=0; obj<data.objects.length; obj++ ) { // Loop Objects
                    
                    var faces = []; // Each face gets its own material because they each can have different colors
                    if (data.objects[obj].facesToFacets.length > 0) {
                        for ( var f=0; f<data.objects[obj].facesToFacets.length; f++ ) {
                            var facecolor = data.objects[obj].color;
                            if (data.objects[obj].faceColors.length > 0) {
                                facecolor = data.objects[obj].faceColors[f];
                            }
                            positions = new Float32Array( data.objects[obj].facesToFacets[f].length * 9 );
                            for ( var a=0; a<data.objects[obj].facesToFacets[f].length; a++ ) {
                                for ( var b=0; b<3; b++ ) {
                                    for ( var c=0; c<3; c++ ) {
                                        positions[ 9*a + 3*b + c ] = data.objects[obj].verts[ 3*data.objects[obj].facets[ 3*data.objects[obj].facesToFacets[f][a] + b ] + c ];
                                    }
                                }
                            }
                            assignMesh( positions, facecolor, data.objects[obj].opacity );
                        }
                    } else { // No facesToFacets means that there was a tessellate() mismatch inside FreeCAD. Use all facets in object create this mesh
                        positions = new Float32Array( data.objects[obj].facets.length * 3 );
                        for ( var a=0; a<data.objects[obj].facets.length; a++ ) {
                            for ( var b=0; b<3; b++ ) {
                                positions[ 3*a + b ] = data.objects[obj].verts[ 3*data.objects[obj].facets[a] + b ];
                            }
                        }
                        assignMesh( positions, data.objects[obj].color, data.objects[obj].opacity );
                    }
                    
                    // Wires
                    // cannot have lines in WebGL that are wider than 1px due to browser limitations so Line2 workaround lib is used
                    // REF: https://threejs.org/examples/?q=fat#webgl_lines_fat - https://jsfiddle.net/brLk6aud/1/
                    var wirematerial = new LineMaterial( {
                        color: new THREE.Color('rgb(0,0,0)'),
                        linewidth: 2, // in pixels
                        dashed: false, dashSize: 1, gapSize: 1, dashScale: 3
                    } );
                    wirematerial.resolution.set( window.innerWidth, window.innerHeight );
                    
                    var wires = [];
                    for ( var w=0; w<data.objects[obj].wires.length; w++ ) {
                        var wiregeometry = new LineGeometry();
                        wiregeometry.setPositions( data.objects[obj].wires[w] );
                        var wire = new Line2( wiregeometry, wirematerial );
                        wire.computeLineDistances();
                        wire.scale.set( 1, 1, 1 );
                        wire.name = wire.uuid;
                        scene.add( wire );
                        wires.push( wire.name );
                    }
                    objects.push( { name: data.objects[obj].name, faces: faces, wires: wires } );
                }
                
                // ---- GUI Init ----
                const gui = new GUI( { width: 300 } );
                var guiparams = {
                    wiretype: 'Normal',
                    wirewidth: wirematerial.linewidth,
                    wirecolor: '#'+wirematerial.color.getHexString(),
                    clippingx: 100,
                    clippingy: 100,
                    clippingz: 100,
                    cameraType: cameraType,
                    navright: function() { navChange( [1,0,0] ); },
                    navtop:   function() { navChange( [0,1,0] ); },
                    navfront: function() { navChange( [0,0,1] ); }
                };
                
                // ---- Wires ----
                if (!wirematerial.visible) { guiparams.wiretype = 'None'; }
                if (wirematerial.dashed) { guiparams.wiretype = 'Dashed'; }
                const wiretypes = { Normal: 'Normal', Dashed: 'Dashed', None: 'None' };
                
                var wireFolder = gui.addFolder( 'Wire' );
                wireFolder.add( guiparams, 'wiretype', wiretypes ).name('Wire Display').onChange( wireChange );
                wireFolder.add( guiparams, 'wirewidth').min(1).max(5).step(1).name('Wire Width').onChange( wireChange );
                wireFolder.addColor( guiparams, 'wirecolor' ).name('Wire Color').onChange( wireChange );
                wireFolder.close();
                
                function wireChange() {
                    for ( var obj=0; obj<objects.length; obj++ ) {
                        if ( objects[obj].wires.length == 0 ) { continue; }
                        var m = scene.getObjectByName( objects[obj].wires[0] ).material; // all wires in obj share mat
                        if (m.dashed) {
                            if (guiparams.wiretype != 'Dashed') {
                                m.dashed = false;
                                delete m.defines.USE_DASH;
                            }
                        } else {
                            if (guiparams.wiretype == 'Dashed') {
                                m.dashed = true;
                                // Dashed lines require this as of r122. delete if not dashed
                                m.defines.USE_DASH = ""; // https://discourse.threejs.org/t/dashed-line2-material/10825
                            }
                        }
                        if (guiparams.wiretype == 'None') {
                            m.visible = false;
                        } else {
                            m.visible = true;
                        }
                        m.linewidth = guiparams.wirewidth;
                        m.color = new THREE.Color(guiparams.wirecolor);
                        m.needsUpdate = true;
                    }
                }
                wireChange();
                
                // ---- Clipping ----
                var clippingFolder = gui.addFolder( 'Clipping' );
                clippingFolder.add( guiparams, 'clippingx').min(0).max(100).step(1).name('X-Axis Clipping').onChange( clippingChange );
                clippingFolder.add( guiparams, 'clippingy').min(0).max(100).step(1).name('Y-Axis Clipping').onChange( clippingChange );
                clippingFolder.add( guiparams, 'clippingz').min(0).max(100).step(1).name('Z-Axis Clipping').onChange( clippingChange );
                clippingFolder.close();
                
                var clipPlaneX = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), 0 );
                var clipPlaneY = new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), 0 );
                var clipPlaneZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), 0 );
                function clippingChange() {
                    if( guiparams.clippingx < 100 || guiparams.clippingy < 100 || guiparams.clippingz < 100 ) {
                        if (renderer.clippingPlanes.length == 0) {
                            renderer.clippingPlanes.push( clipPlaneX, clipPlaneY, clipPlaneZ );
                        }
                    }
                    clipPlaneX.constant = (globalMaxMin[0].max - globalMaxMin[0].min) * guiparams.clippingx / 100.0 + globalMaxMin[0].min;
                    clipPlaneY.constant = (globalMaxMin[1].max - globalMaxMin[1].min) * guiparams.clippingy / 100.0 + globalMaxMin[1].min;
                    clipPlaneZ.constant = (globalMaxMin[2].max - globalMaxMin[2].min) * guiparams.clippingz / 100.0 + globalMaxMin[2].min;
                }
                
                // ---- Camera & Navigation ----
                var camFolder = gui.addFolder( 'Camera' );
                const cameraTypes = { Perspective: 'Perspective', Orthographic: 'Orthographic' };
                camFolder.add( guiparams, 'cameraType', cameraTypes ).name('Wire Display').onChange( cameraChange );
                camFolder.add( guiparams, 'navright' ).name('View Right');
                camFolder.add( guiparams, 'navtop' ).name('View Top');
                camFolder.add( guiparams, 'navfront' ).name('View Front');
                function navChange( v ) {
                    var t = new THREE.Vector3();
                    new THREE.Box3().setFromObject(scene).getSize( t );
                    persControls.object.position.set( v[0]*t.x + camCenter.x, v[1]*t.y + camCenter.y, v[2]*t.z + camCenter.z);
                    persControls.target = camCenter;
                    persControls.update();
                    orthControls.object.position.set( v[0]*t.x + camCenter.x, v[1]*t.y + camCenter.y, v[2]*t.z + camCenter.z);
                    orthControls.target = camCenter;
                    orthControls.update();
                }
                function cameraChange( v ) {
                    cameraType = v;
                }
                
                var guiObjData = [];
                var guiObjects = gui.addFolder( 'Objects' );
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    guiObjData.push( {index: obj, color: data.objects[obj].color, opacity:data.objects[obj].opacity } );
                    var guiObject = guiObjects.addFolder( objects[obj].name );
                    guiObject.addColor( guiObjData[ guiObjData.length-1 ], 'color' ).name('Color').onChange( GUIObjectChange );
                    guiObject.add( guiObjData[ guiObjData.length-1 ], 'opacity' ).min(0.0).max(1.0).step(0.05).name('Opacity').onChange( GUIObjectChange );
                }
                function GUIObjectChange( v ) {
                    for ( var f=0; f<objects[this.object.index].faces.length; f++ ) {
                        var m = scene.getObjectByName( objects[this.object.index].faces[f] ).material;
                        if (this.property == 'color') { m.color.setStyle( v ); }
                        if (this.property == 'opacity') {
                            m.opacity = v;
                            if ( v == 1.0 ) { m.transparent = false; } else { m.transparent = true; }
                        }
                    }
                    if (this.property == 'opacity' && objects[ this.object.index ].wires.length > 0) {
                        var w = scene.getObjectByName( objects[ this.object.index ].wires[0] ).material; // all wires in obj share mat
                        w.opacity = v;
                        if ( v == 1.0 ) { w.transparent = false; } else { w.transparent = true; }
                    }
                }
                
                // Make simple orientation arrows and box - REF: http://jsfiddle.net/b97zd1a3/16/
                var arrowCanvasSize = { x: 150, y: 150 }; // in pixels on the lower left
                var arrowRenderer = new THREE.WebGLRenderer( { alpha: true } ); // clear
                arrowRenderer.setClearColor( 0x000000, 0 );
                arrowRenderer.setSize( arrowCanvasSize.x, arrowCanvasSize.y );
                
                var arrowCanvas = document.body.appendChild( arrowRenderer.domElement );
                arrowCanvas.setAttribute('id', 'arrowCanvas');
                arrowCanvas.style.width = arrowCanvasSize.x;
                arrowCanvas.style.height = arrowCanvasSize.y;
                      
                var arrowScene = new THREE.Scene();
                
                var arrowCamera = new THREE.PerspectiveCamera( 50, arrowCanvasSize.x / arrowCanvasSize.y, 1, 500 );
                arrowCamera.up = persCamera.up; // important!
                
                var arrowPos = new THREE.Vector3( 0,0,0 );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 1,0,0 ), arrowPos, 60, 0x7F2020, 20, 10 ) );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 0,1,0 ), arrowPos, 60, 0x207F20, 20, 10 ) );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 0,0,1 ), arrowPos, 60, 0x20207F, 20, 10 ) );
                arrowScene.add(new THREE.Mesh(
                    new THREE.BoxGeometry( 40, 40, 40 ),
                    new THREE.MeshLambertMaterial( { color: 0xaaaaaa, flatShading: false } )
                ));
                arrowScene.add(new THREE.HemisphereLight(0xC7E8FF, 0xFFE3B3, 1.2));
                
                // Controls
                var persControls = new OrbitControls( persCamera, renderer.domElement );
                persControls.target = camCenter; // rotate around center of parts
                persControls.update();
                var orthControls = new OrbitControls( orthCamera, renderer.domElement );
                orthControls.target = camCenter; // rotate around center of parts
                orthControls.update();
                
                window.addEventListener( 'resize', onWindowResize, false );
                onWindowResize();
                
                var stats = new Stats();
                document.body.appendChild( stats.dom );
                
                renderer.domElement.addEventListener( 'mousemove', onMouseMove );
                
                var animate = function () {
                    requestAnimationFrame( animate );
                    
                    persControls.update();
                    if (cameraType == 'Perspective') {
                        arrowCamera.position.copy( persCamera.position );
                        arrowCamera.position.sub( persControls.target );
                    }
                    orthControls.update();
                    if (cameraType == 'Orthographic') {
                        arrowCamera.position.copy( orthCamera.position );
                        arrowCamera.position.sub( orthControls.target );
                    }
                    arrowCamera.lookAt( arrowScene.position );
                    arrowCamera.position.setLength( 200 );
                    
                    stats.begin();
                    if (cameraType == 'Perspective') { renderer.render( scene, persCamera ); }
                    if (cameraType == 'Orthographic') { renderer.render( scene, orthCamera ); }
                    arrowRenderer.render( arrowScene, arrowCamera );
                    stats.end();
                };
                animate();
                
                function onWindowResize() {
                    for ( var obj=0; obj<objects.length; obj++ ) {
                        if (objects[obj].wires.length > 0) {
                            var w = scene.getObjectByName( objects[obj].wires[0] ).material.resolution.set( window.innerWidth, window.innerHeight ); // all wires in obj share mat
                        }
                    }
                    
                    // Ortho camera needs updating. REF: https://stackoverflow.com/questions/39373113/three-js-resize-window-not-scaling-properly
                    var aspect = window.innerWidth / window.innerHeight;
                    var change = originalAspect / aspect;
                    var newSize = viewSize * change;
                    orthCamera.left = -aspect * newSize / 2;
                    orthCamera.right = aspect * newSize  / 2;
                    orthCamera.top = newSize / 2;
                    orthCamera.bottom = -newSize / 2;
                    orthCamera.updateProjectionMatrix();
                    
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                
                function onMouseMove( e ) {
                    var c = false;
                    if (cameraType == 'Orthographic') { c = orthCamera;}
                    if (cameraType == 'Perspective') { c = persCamera;}
                    if (!c) { return; }
                    
                    var raycaster =  new THREE.Raycaster();                                        
                    raycaster.setFromCamera( new THREE.Vector2(
                        ( e.clientX / window.innerWidth ) * 2 - 1,
                        -( e.clientY / window.innerHeight ) * 2 + 1
                    ), c );
                    var intersects = raycaster.intersectObjects( raycasterObj );
                    
                    var chosen = '';
                    if ( intersects.length > 0 ) {
                        for ( var i=0; i<intersects.length; i++ ) {
                            var m = intersects[i].object.material;
                            if (m.opacity > 0) {
                                if (m.emissive.getHex() == 0x000000) {
                                    m.emissive.setHex( 0x777777 );
                                    m.needsUpdate = true;
                                }
                                chosen = intersects[i].object.name;
                                break;
                            }
                        }
                    }
                    for ( var r=0; r<raycasterObj.length; r++ ) {
                        if (raycasterObj[r].name == chosen) { continue; }
                        if (raycasterObj[r].material.emissive.getHex() != 0x000000) {
                            raycasterObj[r].material.emissive.setHex( 0x000000 );
                            raycasterObj[r].material.needsUpdate = true;
                        }
                    }
                }
                data = false; // free up some ram
            </script>
        </body>
    </html>
